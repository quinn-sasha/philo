餓死する最悪のケース：
1. P2がP1の食事を待って、P1の食事が終わりフォークを取る
2. P2がフォークを取ろうとすると、運悪くP3がもう片方のフォークを少し早く取得していた

die: 400ms
eat: 200ms
sleep: 195ms
think: about 0ms

3人の哲学者(P1, P2, P3)の例 (P2が餓死する)
1. T = 0の時点で食事を終える (HP = 400m)
2. 195ms sleep (HP = 205ms)
P1 and P3 の食事時間の合計 = 400ms
もし起きた時点でちょうど P1 にフォークを取られ P1 の食事が終わるのを待った後、
片方のフォークを取ろうとしたら P3 にフォークを取られると餓死する.

回避方法:
「P2 がはじめのフォークを取ったら、すぐに P3 が片方のフォークを取る」という可能性を下げたい.
例えば偶数の哲学者は、1ms 考えるようにさせる.
こうすると、P1 が食事を終えたあとに、P3がフォークを取りに来ることは少なくなる (P2が先に取る場合と、P3を待つ場合がある)
理論的に 100% 餓死がなくなるわけではないけど、かなり低い確率になると思う.

疑問：
- 課題の sleep と関数の sleep は違うのか

strlen() and strcmp()で最大値より大きいか検出できる

引数の条件:
- 0 <= x <= SIZE_MAX (哲学者の数 >= 1)
- 正の整数

テストする項目：
- 引数が有効かどうか
-


(now - start_of_last_meal_time) <= time_to_die 生存
(now - start_of_last_meal_time) > time_to_die 餓死

引数の情報は一つの構造体にまとめる（時間には int よりも long とかの方が良さそう）
引数の解析で無効な入力なら、EXIT_FAILUREを返す
INT_MAX(SIZE_MAX) とft_strcmp()で比べて、INT_MAX より大きければ無効とする
number_of_times_each_philosopher_must_eat == 0 だと有効ではないか？
開始時刻を今の1秒後に設定しておいて(マイクロ秒は切り捨て)

哲学者構造体に必要な情報:
- thread id
- info へのポインタ
- id
- eat_count
- last_eat_time
- mutex for eat_count and last_eat_time (哲学者と監視者の2種類が共有することがあるので、mutexが必要)
- 行動状態(optional)
- フォークへのぽいんた

監視者の情報：
- thread id
- シュミレーションの終了条件を示すフラグ
- mutex for write (printf) or is_dead(is_finished)
mutex for log は監視者が使わなくても良いのか（監視者がログを書かなくてもいいのか）
監視者の役割は、シュミレーションの続行判断と死者が出たことの判定か

next_eat_at 変数に、usleep_until(next_eat_at)を呼ぶことで、考える時間の長さを調整できる（便利）


監視者のコードを読んでいた
