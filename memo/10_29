餓死する最悪のケース：
1. P2がP1の食事を待って、P1の食事が終わりフォークを取る
2. P2がフォークを取ろうとすると、運悪くP3がもう片方のフォークを少し早く取得していた

die: 400ms
eat: 200ms
sleep: 195ms
think: about 0ms

3人の哲学者(P1, P2, P3)の例 (P2が餓死する)
1. T = 0の時点で食事を終える (HP = 400m)
2. 195ms sleep (HP = 205ms)
P1 and P3 の食事時間の合計 = 400ms
もし起きた時点でちょうど P1 にフォークを取られ P1 の食事が終わるのを待った後、
片方のフォークを取ろうとしたら P3 にフォークを取られると餓死する.

回避方法:
「P2 がはじめのフォークを取ったら、すぐに P3 が片方のフォークを取る」という可能性を下げたい.
例えば偶数の哲学者は、1ms 考えるようにさせる.
こうすると、P1 が食事を終えたあとに、P3がフォークを取りに来ることは少なくなる (P2が先に取る場合と、P3を待つ場合がある)
理論的に 100% 餓死がなくなるわけではないけど、かなり低い確率になると思う.

疑問：
- 課題の sleep と関数の sleep は違うのか

strlen() and strcmp()で最大値より大きいか検出できる

引数の条件:
- 0 <= x <= SIZE_MAX (哲学者の数 >= 1)
- 正の整数

テストする項目：
- 引数が有効かどうか
-


(now - start_of_last_meal_time) <= time_to_die 生存
(now - start_of_last_meal_time) > time_to_die 餓死


