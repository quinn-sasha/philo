任意のスレッドを pthread_join()する方法
mutex以外にも barrier, rwlock, spin_lock とかもあって面白い
- barrier: ロックを獲得しようとするスレッドが、ある数までに達すると、ロックが解除される
- rwlock:
  - 共有資源が read と write の２つあり、それぞれに別のロックがかけらている
  - どちらかの資源を参照すると、片方の資源にアクセスできない
  - read は複数のスレッドが同時にアクセスできるが、write は1つのスレッドのみ
  - 書き込みがすくない資源に向いている
- spinlock: mutexと異なる点:
  - ロックを待つ時に CPU を手放さないこと.
  - mutex は内部でシステムコールを使ってスレッドをブロックしたり起こしたりしている.
  - CPUを消費する点は無駄使いな印象だけど、その後の実行の再開が軽い
  - 待ち時間が短い場合に向いている

ログに書き込むときも、排他的にする必要がある

pthread_once()の使いどころよくわからない
スレッド固有データの例としては、errno とか
とりあえず本は中断。キーと確保した領域を対応付ける説明まで読んだ。

次はコードやブログを読んで、他の人の解法を見る.
調停者スレッドを立てて、フォークを取るための許可を取らせることで、公平に食べる機会が与えられる

## 仮実装案
フォークを取る順番：フォークに数字を割り当てて、小さい順に取る（先に取得するフォークを計算しておく）
この方法だとフォークの取り合いで、片方が負け続けると餓死する可能性が十分にある.
これを回避するには、食べる -> 眠る -> 考える -> new 少し眠る（時間は奇数と偶数で少しずらす）
また食べに行く前に少し眠ることで、隣り合うスレッドが一方的にフォークを取れなくなる可能性が下がる（はず）

他にわからないこと：
- ログを書く方法（監視者がなぜ必要なのかまだ不明）
- どれくらい考える時間を与えればいいのか不明（超短時間だけとか？）
- その他もろもろの実装の雰囲気

監視用のスレッドの処理はどのようなものがあるのだろう
条件: now - last_meal_time >= time_to_die

やっぱ並列処理の場合に、同時に食べれないのは良くないので、waiter解法は却下.
デッドロックはわかりやすい問題だが、それ以外にも公平性などの問題がある.

