- ログを出力する関数を理解するのが難しい
- philo_eat()を理解する
- ログを出力する関数を呼び出して、時間も取得できるようにするとよさそう

実装に入ろう

## デッドロックの回避
フォークに数字を割り当てて、小さい順にフォークを取るようにする.

## 公平性
偶奇で哲学者が最初に食べ始めるタイミングをずらす.
前回食べた時間から、次食べるまでの時間はだいたい time_to_eat*2 になる.

## 数式
### Optimal interval (前回食事を始めてから次に食事するまでの間隔)
n = 2k or n = 2k + 1
k = n / 2 (同時に食事をできる哲学者数)
optimal interval = time_to_eat * (n / k)
n / k ≒ 2 だから
optimal interval = time_to_eat * 2 (２つのグループが両方とも食事を終えるまでにかかる最低限の時間)

### 最初に食べ始めるタイミング
initial_slot = (k * philo_id) % n
initial_slot: 各哲学者の開始時刻をIDに基づいて順位付けする

initial_eat_at = start + (time_to_eat / k) * initial_slot
time_to_eat / k: 同じグループに属するk人の哲学者が time_to_eat 間で食事を始められるようにするためにずらす時間
initial_eat_at = 一人分のズレ幅 * 自分のスタートする順位

プレイヤー：哲学者 n人、監視者1人
監視者の役割：シュミレーションを継続するかどうかの判定をする

1. プログラム引数が有効化どうか判定する
2. 全体のデータ（時間や哲学者、フォークなど）を初期化する
3. 哲学者と監視者のスレッドを作る（シュミレーションスタート）
4. 全てのスレッドが終わるのを待って、それらを解放する


number_of_philosophers: 哲学者の人数、およびフォークの総数
1 ~ MAX_PHILO

time_to_die（ミリ秒単位）: 最後の食事開始時点またはシミュレーション開始から time_to_die ミリ秒以内に食事を開始しなかった哲学者は死亡します。
0 ~
time_to_eat（ミリ秒単位）: 哲学者が食事を完了するのに必要な時間。この期間中はフォークを2本保持している必要があります。
0 ~
time_to_sleep（ミリ秒単位）: 哲学者が睡眠に費やす時間
0 ~
number_of_times_each_philosopher_must_eat（任意の引数）: すべての哲学者が少なくとも number_of_times_each_philosopher_must_eat 回食事を終えた場合、シミュレーションは終了します。
1 ~


引数の解析は終わったと思う
構造体の設計（仮）まで書きたい
